<!-- Curso de canvas CFB. Exercício: desenvolver o jogo PONG -->

<!DOCTYPE html>
<html lang="en">

<head>

    <script src="Boll.js"></script>
    <script src="Player.js"></script>

    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title> Pong Game </title>
</head>

<style>

    #canvas1{
        width: 800px;
        height: 600px;
        background-color: black;
        border-left: 3px solid black;
        border-right: 3px solid black;
        border-bottom: 5px solid #00FF7F;
        border-top: 5px solid #00FF7F;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%,-50%);
    }
    #btn{
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%,-50%);
        width: 200px;
        height: 60px;
        border-radius: 10px;
    }
    #btn:hover{
        background-color: greenyellow;
        color: darkgray;
        font-size: large;
    }

</style>

<body>

    <canvas id="canvas1" class="canvas1"> ERRO! </canvas>
    <input type="button" id="btn" value=" Start ">
    
    
</body>

<script>

    const btn_play = document.getElementById('btn');

    const canvas = document.getElementById('canvas1');
    const  ctx = canvas.getContext('2d');

    const CANVAS_WIDTH = canvas.width = 800;
    const CANVAS_HEIGHT = canvas.height = 600;

    var player_points = 0;
    var npcPlayer_points = 0;


    window.addEventListener('keydown', function(e){
        keyDown(e.keyCode);
    });
    window.addEventListener('keyup', function(e){
        keyUp(e.keyCode);
    });
    btn_play.addEventListener('click', function(){
        console.log('Start Game =D');
        // start game
        animate();
        this.remove();
    });

    const boll = new Boll();
    const player1 = new Player();
    const npcPlayer = new Player();
    ini();

    // configura o inicio do jogo
    // posiciona os jogadores e a bola em suas respectivas posições inicias
    function ini(){
        //
        boll.x = canvas.width/2 - boll.width/2;
        boll.y = canvas.height/2 - boll.height/2;
        boll.direction.x = 1; // começa para direita
        boll.direction.y = 0;
        //
        player1.x = 0;
        player1.y = (canvas.height/2 - player1.height /2);
        //
        npcPlayer.x = canvas.width - npcPlayer.width;
        npcPlayer.y = (canvas.height/2 - npcPlayer.height /2);
        npcPlayer.color = "#E9967A";
    }

    function animate(){
        console.log('animate');
        update_player_position(); // posicao do jogador
        update_boll_position(); // atualiza a posição da bola
        update_npcPlayer_position();
        clear();
        drawCenterLine();
        player1.draw(ctx); // desenha o jogador
        npcPlayer.draw(ctx);
        boll.draw(ctx);
        drawScoreboard();
        requestAnimationFrame(animate);
    }

    function drawScoreboard(){
        ctx.beginPath();
        ctx.font = '50px Verdana';
        ctx.fillStyle = '#4F4F4F';
        ctx.fillText(`${player_points}`, CANVAS_WIDTH/2 - 80 , 100);
        ctx.fillText(`${npcPlayer_points}`, CANVAS_WIDTH/2 + 50 , 100);
        ctx.closePath();
    }

    // linha que divide o campo
    function drawCenterLine(){
        //
        ctx.beginPath();
        ctx.strokeStyle = '#C0C0C0';
        ctx.lineWidth = 2; // largura do contorno
        ctx.moveTo(CANVAS_WIDTH/2,0);
        ctx.lineTo(CANVAS_WIDTH/2,CANVAS_HEIGHT);
        ctx.stroke();
        ctx.closePath();
    }

    function clear(){
        ctx.clearRect(0,0,CANVAS_WIDTH,CANVAS_HEIGHT);
    }

    // testa se o movimento esta dentro das dimensões do canvas
    // recebe a coordenada y para onde o quadrado quer mover e a altura do player
    // retorna TRUE se o movimento é valido.
    function player_collision(y, height){

        if(y < 0 || y > CANVAS_HEIGHT - height){
            return false;
        }

        console.log(`movimento válido 0 - ${y}`);
        return true;

    }

    // atualiza as coordenadas do jogador se o movimento for válido.
    function update_player_position(){

        if( player1.direction.up == true){
            if(player_collision(player1.y - player1.vel, player1.height) == true) {
                player1.y -=  player1.vel;
            }
        }
        if( player1.direction.down == true){
            if(player_collision(player1.y + player1.vel, player1.height) == true){
                player1.y +=  player1.vel;
            }
        }

    }

    function update_npcPlayer_position(){ // ARRUMAR ISSO AQUI PARA IR EXATAMENTE NA POSICAO DA BOLA

        // se a bola estiver indo para a direita
        // se a bola passou do meio
        // então começa a ir atrás dela
        if( (boll.x > CANVAS_WIDTH / 2) && (boll.direction.x  > 0) ){
            // se o meio da bola estiver com o y maior que o y middle do npc, vai para baixo y+=
            if( (boll.y + boll.height / 2) > (npcPlayer.y + npcPlayer.y_middle) ){
                // PC VAI PARA BAIXO
                if( player_collision(npcPlayer.y + npcPlayer.vel, npcPlayer.height) == true){
                    npcPlayer.y +=  npcPlayer.vel;
                }
            }
            // se o meio da bola estiver com o y menor que o y middle do npc então vai para cima y-=
            else if( (boll.y + boll.height / 2) < (npcPlayer.y + npcPlayer.y_middle)){
                // PC VAI PARA CIMA
                if( player_collision(npcPlayer.y - npcPlayer.vel, npcPlayer.height) == true){
                    npcPlayer.y -=  npcPlayer.vel;
                }
            }
        }
        // se a bola estiver indo para a esquerda (valor negativo) o pad começa a voltar para o meio do campo
        else if(boll.direction.x < 0){
            if( npcPlayer.y > CANVAS_HEIGHT / 2 - npcPlayer.height / 2){ // CRIAR FUNCAO GENERICA
                npcPlayer.y -=  npcPlayer.vel;
            }
            if( npcPlayer.y < CANVAS_HEIGHT / 2 - npcPlayer.height / 2){
                npcPlayer.y +=  npcPlayer.vel;
            }
        }
    }

    // ALTERAR ESTE NOME PARA UPDATE
    function update_boll_position(){

        // atualiza as coordenadas
        boll.x += boll.direction.x * boll.vel;
        boll.y += boll.direction.y * boll.vel;
        // testa o movimento feito
        boll_collision();
        //
        console.log(` direction.x: ${boll.direction.x}  direction.y: ${boll.direction.y} || [x:${boll.x}]  [y:${boll.y}] `);

    }

    function boll_collision(){

        // se foi GOL
        if(boll.x >= canvas.width - boll.width){
            // GOL DO PLAYER
            goal();
            // bola vai para o lado de quem levou o gol
            // boll.direction.x = 1;
        }
        if(boll.x <= 0){
            // GOL DO NPC
            goal();
            // bola vai para o lado de quem levou o gol
            // boll.direction.x = -1;
        }
        // SE passou de um dos limites então reposiciona o y da bola
        if(boll.y <= 0){
            // CALCULO para mudar a direção de y mas sem perder a valocidade calculada na colisao.
            boll.direction.y *= (-1);
            console.log(`COLISÃO: parede de cima | boll.y[${boll.y}] = 0`);
            boll.y = 0;
        }
        if(boll.y >= canvas.height - boll.height){
            //
            boll.direction.y *= (-1);
            console.log(`COLISÃO: parede de baixo | boll.y[${boll.y}] = height limite`);
            boll.y = canvas.height - boll.height;
        }

        // colisao da bola contra o player   TENTAR OTIMIZAR ESTA PARTE, CÓDIGO É IGUAL EM AMBAS CONDICIONAIS
        //
        if(boll.x <= player1.x + player1.width && boll.x + boll.width >= player1.x 
            && boll.y <= player1.y + player1.height && boll.y + boll.height >= player1.y ){ // margem esquerda
                //
                boll.direction.x = 1;
                boll.direction.y = ((boll.y + boll.height/2) - (player1.y + player1.height/2)) / player1.division; // isso muda o angulo da direção da bola
                console.log(`COLISÃO: bola contra o Player | Direction.Y: ${boll.direction.y}`);
        }
        else if(boll.x <= npcPlayer.x + npcPlayer.width && boll.x + boll.width >= npcPlayer.x 
            && boll.y <= npcPlayer.y + npcPlayer.height && boll.y + boll.height >= npcPlayer.y ){ // margem esquerda
                boll.direction.x = -1;
                boll.direction.y = ((boll.y + boll.height/2) - (npcPlayer.y + npcPlayer.height/2)) / npcPlayer.division;
                console.log(`COLISÃO: bola contra o npc_Player | Direction.Y: ${boll.direction.y} `);
                npcPlayer.middleRandom();
        }
        //

    }

    function goal(){
        // posiciona a bola no meio
        boll.x = canvas.width/2 - boll.width/2;
        boll.y = canvas.height/2 - boll.height/2;
        //
        boll.direction.y = 0;
        //
        // atualiza o placar
        if(boll.direction.x == 1){
            // gol do player
            player_points ++;
        }
        else{
            // gol do npc
            npcPlayer_points ++;
        }  
    }

    // pressionar a tecla
    function keyDown(move){

        //console.log('KEY DOWN EVENT');
        //console.log(position);
        // UTILIZANDO OUTRA LÓGICA AQUI PARA TESTAR

        switch(move){
            case 38: // cima
                player1.direction.up = true;
                break;
            case 40: //baixo
                player1.direction.down = true;
                break;
        }
    }

    // quando soltar a tecla
    function keyUp(move){
        
        //console.log(position);

        switch(move){
            case 38: // cima
                player1.direction.up = false;
                break;
            case 40: //baixo
                player1.direction.down = false;
                break;
        }
    }

    // start
    //animate();

</script>

</html>